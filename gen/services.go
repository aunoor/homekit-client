package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"strings"

	"gopkg.in/yaml.v3"
)

type serviceConfig struct {
	Name string
	UUID string
}

func (s *serviceConfig) TypeConstant() string {
	return "Type" + pascalCase(s.Name)
}

func (s *serviceConfig) JSONUUID() string {
	if strings.HasSuffix(s.UUID, appleBaseUUID) {
		return strings.TrimLeft(s.UUID[:len(s.UUID)-len(appleBaseUUID)], "0")
	}
	return s.UUID
}

// GenerateServices generates go source files that implement the services
// defined in services.yaml
func GenerateServices() error {
	cfgData, err := ioutil.ReadFile("services.yaml")
	if err != nil {
		return err
	}

	var cfgs []serviceConfig
	if err := yaml.Unmarshal(cfgData, &cfgs); err != nil {
		return fmt.Errorf("unmarshal config: %v", err)
	}

	var w bytes.Buffer
	sGen := serviceGenerator{w: &w}
	if err := sGen.writeTypes(cfgs); err != nil {
		return err
	}

	formattedSrc, err := format.Source(w.Bytes())
	if err != nil {
		return err
	}

	if err := ioutil.WriteFile("service_types.go", formattedSrc, 0755); err != nil {
		return err
	}

	return nil
}

type serviceGenerator struct {
	w    io.Writer
	wErr error
}

func (s *serviceGenerator) writeTypes(cfgs []serviceConfig) error {
	s.printf("// generated by cmd/gen; DO NOT EDIT\n\n")
	s.printf("package service\n\n")

	s.printf("const (\n")
	for _, cfg := range cfgs {
		s.printf("\t%s = %q\n", cfg.TypeConstant(), cfg.JSONUUID())
	}
	s.printf(")\n\n")

	s.printf("var typeMetadatas = []*TypeMetadata{\n")
	for _, cfg := range cfgs {
		s.printf("\t{%s, %q},\n", cfg.TypeConstant(), pascalCase(cfg.Name))
	}
	s.printf("}\n")

	if s.wErr != nil {
		return fmt.Errorf("failed to write: %v", s.wErr)
	}

	return nil
}

func (s *serviceGenerator) printf(format string, a ...interface{}) {
	if s.wErr != nil {
		return
	}
	_, s.wErr = fmt.Fprintf(s.w, format, a...)
}
