package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	appleBaseUUID = "-0000-1000-8000-0026BB765291"
)

type characteristicConfig struct {
	Name   string
	UUID   string
	Format string
}

func (c *characteristicConfig) TypeConstant() string {
	return "Type" + c.TypeName()
}

func (c *characteristicConfig) TypeName() string {
	return strings.ReplaceAll(pascalCase(c.Name), ".", "")
}

func (c *characteristicConfig) JSONUUID() string {
	if strings.HasSuffix(c.UUID, appleBaseUUID) {
		return strings.TrimLeft(c.UUID[:len(c.UUID)-len(appleBaseUUID)], "0")
	}
	return c.UUID
}

// GenerateCharacteristics generates go source files that implement the characteristics
// defined in characteristics.yaml
func GenerateCharacteristics() error {
	cfgData, err := ioutil.ReadFile("characteristics.yaml")
	if err != nil {
		return err
	}

	var cfgs []characteristicConfig
	if err := yaml.Unmarshal(cfgData, &cfgs); err != nil {
		return fmt.Errorf("unmarshal config: %v", err)
	}

	if err := generateCharacteristicTypes(cfgs); err != nil {
		return fmt.Errorf("generateCharacteristicTypes: %v", err)
	}

	if err := generateCharacteristicReaders(cfgs); err != nil {
		return fmt.Errorf("generateCharacteristicReaders: %v", err)
	}

	return nil
}

func generateCharacteristicTypes(cfgs []characteristicConfig) error {
	var w bytes.Buffer
	cGen := characteristicGenerator{w: &w}
	if err := cGen.writeTypes(cfgs); err != nil {
		return err
	}

	if err := ioutil.WriteFile("characteristic_types.go", w.Bytes(), 0755); err != nil {
		return err
	}

	return nil
}

func generateCharacteristicReaders(cfgs []characteristicConfig) error {
	var w bytes.Buffer
	cGen := characteristicGenerator{w: &w}
	if err := cGen.writeReaders(cfgs); err != nil {
		return err
	}

	formattedSrc, err := format.Source(w.Bytes())
	if err != nil {
		return err
	}

	if err := ioutil.WriteFile("characteristic_readers.go", formattedSrc, 0755); err != nil {
		return err
	}

	return nil
}

type characteristicGenerator struct {
	w    io.Writer
	wErr error
}

func (c *characteristicGenerator) writeTypes(cfgs []characteristicConfig) error {
	c.printf("// Code generated by cmd/gen. DO NOT EDIT.\n\n")
	c.printf("package characteristic\n\n")

	c.printf("const (\n")
	for _, cfg := range cfgs {
		c.printf("\t%s = %q\n", cfg.TypeConstant(), cfg.JSONUUID())
	}
	c.printf(")\n\n")

	c.printf("var typeMetadatas = []*TypeMetadata{\n")
	for _, cfg := range cfgs {
		c.printf("\t{%s, %q, %q},\n", cfg.TypeConstant(), pascalCase(cfg.Name), cfg.Format)
	}
	c.printf("}\n")

	if c.wErr != nil {
		return fmt.Errorf("failed to write: %v", c.wErr)
	}

	return nil
}

func (c *characteristicGenerator) writeReaders(cfgs []characteristicConfig) error {
	c.printf("// Code generated by cmd/gen. DO NOT EDIT.\n\n")
	c.printf("package characteristic\n\n")

	for i, cfg := range cfgs {
		typeName := cfg.TypeName()

		if i > 0 {
			c.printf("\n")
		}

		c.printf("type %s struct {\n", typeName)
		c.printf("\tID uint64\n")
		c.printf("\tValue %s\n", goType(cfg.Format))
		c.printf("}\n\n")

		c.printf("func Read%s(ch *RawCharacteristic) *%s {\n", typeName, typeName)
		c.printf("\treturn &%s{\n", typeName)
		c.printf("\t\tID: ch.ID,\n")
		c.printf("\t\tValue: ch.Value.%s(),\n", goTypeConverterFunc(cfg.Format))
		c.printf("\t}\n")
		c.printf("}\n")
	}

	if c.wErr != nil {
		return fmt.Errorf("failed to write: %v", c.wErr)
	}

	return nil
}

func (c *characteristicGenerator) printf(format string, a ...interface{}) {
	if c.wErr != nil {
		return
	}
	_, c.wErr = fmt.Fprintf(c.w, format, a...)
}

func goType(format string) string {
	switch format {
	case "bool":
		return "bool"
	case "uint8":
		return "byte"
	case "uint16":
		return "uint16"
	case "uint32":
		return "uint32"
	case "uint64":
		return "uint64"
	case "int":
		return "int32"
	case "float":
		return "float64"
	case "string":
		return "string"
	case "tlv8", "data": // TODO: look at tlv8/data examples
		return "[]byte"
	default:
		panic("unhandled format: " + format)
	}
}

func goTypeConverterFunc(format string) string {
	switch format {
	case "bool":
		return "MustBool"
	case "uint8":
		return "MustByte"
	case "uint16":
		return "MustUint16"
	case "uint32":
		return "MustUint32"
	case "uint64":
		return "MustUint64"
	case "int":
		return "MustInt32"
	case "float":
		return "MustFloat64"
	case "string":
		return "MustString"
	case "tlv8", "data": // TODO: look at tlv8/data examples
		return "MustBytes"
	default:
		panic("unhandled format: " + format)
	}
}
